import{S as o}from"./p-c74b54ba.js";export{A as ActivityTraits,O as OrderBy,S as SyntaxNames,W as WorkflowContextFidelity,a as WorkflowPersistenceBehavior,b as WorkflowStatus,c as WorkflowTestActivityMessageStatus,g as getVersionOptionsString}from"./p-c74b54ba.js";import{E as i,H as r}from"./p-d8454b73.js";export{E as EventTypes}from"./p-d8454b73.js";export{A as ActivityIconProvider,a as activityIconProvider}from"./p-7462b7bd.js";export{C as ConfirmDialogService,c as confirmDialogService}from"./p-151d0027.js";export{T as ToastNotificationService,t as toastNotificationService}from"./p-7cfaa324.js";export{a as createElsaClient,c as createHttpClient}from"./p-4d2049bc.js";import{e as n}from"./p-93cac3a6.js";export{e as eventBus}from"./p-93cac3a6.js";export{F as FeaturesDataManager,f as featuresDataManager}from"./p-34c33cf9.js";export{P as PluginManager,p as pluginManager}from"./p-1c8d77a0.js";export{P as PropertyDisplayManager,p as propertyDisplayManager}from"./p-e6163d8c.js";import"./p-a3b5bd35.js";import{h as l}from"./p-4ebd2c24.js";import"./p-ca993e0f.js";import"./p-949334ec.js";import{a as m}from"./p-3c89b68a.js";export{d as DashboardTunnel}from"./p-64c0718a.js";export{s as DashboardState}from"./p-e1c2279c.js";import"./p-ee0b9025.js";import"./p-80de33dc.js";import"./p-83f217d4.js";class w{constructor(){n.on(i.ActivityDesignDisplaying,this.onActivityDisplaying),n.on(i.Dashboard.Appearing,this.onLoadingMenu)}onActivityDisplaying(t){const s=t.activityModel;if(!s.type.endsWith("Webhook"))return;const a=(s.properties||[]).find((t=>"Path"==t.name))||{name:"Path",expressions:{Literal:"",syntax:o.Literal}},e=l(a.expressions[a.syntax||o.Literal]);t.bodyDisplay=`<p>${e}</p>`}onLoadingMenu(t){t.data.menuItems=[...t.data.menuItems,["webhook-definitions","Webhook Definitions"]],t.data.routes=[...t.data.routes,["webhook-definitions","elsa-studio-webhook-definitions-list",!0],["webhook-definitions/:id","elsa-studio-webhook-definitions-edit",!1]]}}let u=null,h=null;class j{constructor(t){this.serverUrl=t.serverUrl,n.on(i.WorkflowRegistryLoadingColumns,this.onLoadingColumns),n.on(i.WorkflowRegistryUpdating,this.onUpdating)}onLoadingColumns(t){t.data={headers:[["Enabled"]],hasContextItems:!0}}async onUpdating(t){const s=await async function(t){if(h)return h;const s=await function(t){if(u)return u;const s={baseURL:t};n.emit(i.HttpClientConfigCreated,this,{config:s});const a=m.create(s),o=new r(a);return n.emit(i.HttpClientCreated,this,{service:o,httpClient:a}),u=a}(t);return h={workflowSettingsApi:{list:async()=>(await s.get("v1/workflow-settings")).data,save:async t=>(await s.post("v1/workflow-settings",t)).data,delete:async t=>{await s.delete(`v1/workflow-settings/${t}`)}}},h}(this.serverUrl),a=(await s.workflowSettingsApi.list()).find((s=>s.workflowBlueprintId==t.params[0]&&s.key==t.params[1]));null!=a&&await s.workflowSettingsApi.delete(a.id);const o={workflowBlueprintId:t.params[0],key:t.params[1],value:t.params[2]};await s.workflowSettingsApi.save(o),await n.emit(i.WorkflowRegistryUpdated,this)}}export{w as WebhooksPlugin,j as WorkflowSettingsPlugin}